// Copyright (C) 2022 Storj Labs, Inc.
// See LICENSE for copying information.

package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"strings"
	"text/template"
	"unicode"

	"github.com/zeebo/errs"

	"storj.io/gateway-mt/pkg/auth"
	"storj.io/gateway-mt/pkg/linksharing"
	"storj.io/storj-up/pkg/config"
	"storj.io/storj/satellite"
	"storj.io/storj/storagenode"
)

var configTypes = map[string]reflect.Type{
	"storagenode":     reflect.TypeOf(storagenode.Config{}),
	"satellite-api":   reflect.TypeOf(satellite.Config{}),
	"satellite-admin": reflect.TypeOf(satellite.Config{}),
	"satellite-core":  reflect.TypeOf(satellite.Config{}),
	"linksharing":     reflect.TypeOf(linksharing.Config{}),
	"authservice":     reflect.TypeOf(auth.Config{}),
	//"storjscan":       reflect.TypeOf(storjscan.Config{}),
}

func main() {
	templateDir := "."
	if len(os.Args) > 1 {
		templateDir = os.Args[1]
	}
	for name, t := range configTypes {
		err := generateSingle(templateDir, name, t)
		if err != nil {
			panic(err)
		}
	}
	err := generateCombiner(templateDir, configTypes)
	if err != nil {
		panic(err)
	}
}

func generateCombiner(templateDir string, types map[string]reflect.Type) error {
	fileName := "../all.go"
	fmt.Println("Writing " + fileName)
	f, err := os.Create(fileName)
	if err != nil {
		return errs.Wrap(err)
	}
	defer func() {
		_ = f.Close()
	}()

	file, err := os.Open(filepath.Join(templateDir, "all.tpl"))
	if err != nil {
		return errs.Wrap(err)
	}

	t, err := template.New("all.tpl").
		Funcs(map[string]interface{}{
			"goName": goName,
		}).
		Parse(getFileContents(file))
	if err != nil {
		return errs.Wrap(err)
	}

	err = t.Execute(f, struct {
		Configs map[string]reflect.Type
	}{
		Configs: types,
	})
	return err
}

func generateSingle(templateDir string, name string, root reflect.Type) error {
	fileName := "../" + name + ".go"
	fmt.Println("Writing " + fileName)
	f, err := os.Create(fileName)
	if err != nil {
		return errs.Wrap(err)
	}
	defer func() {
		_ = f.Close()
	}()

	file, err := os.Open(filepath.Join(templateDir, "single.tpl"))
	if err != nil {
		return errs.Wrap(err)
	}

	t, err := template.New("single.tpl").
		Funcs(map[string]interface{}{
			"goName": goName,
		}).
		Parse(getFileContents(file))
	if err != nil {
		return errs.Wrap(err)
	}

	options, err := collectOptions("", root)
	if err != nil {
		return errs.Wrap(err)
	}

	err = t.Execute(f, struct {
		Name    string
		Options []config.Option
	}{
		Name:    name,
		Options: options,
	})

	return err
}

func goName(name string) string {
	return strings.ReplaceAll(name, "-", "")
}

func collectOptions(prefix string, configType reflect.Type) (res []config.Option, err error) {
	if prefix != "" {
		prefix += "."
	}
	for i := 0; i < configType.NumField(); i++ {
		field := configType.Field(i)
		if field.Type.Kind() == reflect.Struct {
			name := prefix + configName(field.Name)
			r, err := collectOptions(name, field.Type)
			if err != nil {
				return res, errs.Wrap(err)
			}
			res = append(res, r...)
		} else {
			name := prefix + configName(field.Name)
			res = append(res, config.Option{
				Name:        name,
				Description: safe(field.Tag.Get("help")),
				Default:     safe(field.Tag.Get("default"))})
		}
	}
	return res, nil
}

func safe(s string) string {
	s = strings.ReplaceAll(s, "\"", "\\\"")
	s = strings.ReplaceAll(s, "\n", "")
	return s
}

func camelToUpperCase(name string) string {
	smallCapital := regexp.MustCompile("([a-z])([A-Z])")
	name = smallCapital.ReplaceAllString(name, "${1}_$2")
	return strings.ToUpper(name)
}

func getFileContents(file *os.File) string {
	scanner := bufio.NewScanner(file)
	// skip first two lines (header)
	scanner.Scan()
	scanner.Scan()

	var fileContent strings.Builder
	// add new autogen header
	fileContent.WriteString("// AUTOGENERATED BY pkg/config/gen" + "\n")
	fileContent.WriteString("// DO NOT EDIT." + "\n")
	for scanner.Scan() {
		fileContent.WriteString(scanner.Text() + "\n")
	}
	return fileContent.String()
}

func hyphenate(val string) string {
	return strings.ReplaceAll(val, "_", "-")
}

func configName(val string) string {
	// don't you think this function should be in the standard library?
	// seems useful
	if len(val) <= 1 {
		return strings.ToLower(val)
	}
	runes := []rune(val)
	rv := make([]rune, 0, len(runes))
	for i := 0; i < len(runes); i++ {
		rv = append(rv, unicode.ToLower(runes[i]))
		if i < len(runes)-1 &&
			unicode.IsLower(runes[i]) &&
			unicode.IsUpper(runes[i+1]) {
			// lower-to-uppercase case
			rv = append(rv, '_')
		} else if i < len(runes)-2 &&
			unicode.IsUpper(runes[i]) &&
			unicode.IsUpper(runes[i+1]) &&
			unicode.IsLower(runes[i+2]) {
			// end-of-acronym case
			rv = append(rv, '_')
		}
	}
	return strings.ReplaceAll(string(rv), "_", "-")
}
